​									***浮点数***



<font style="font-weight:700;">IEEE浮点标准用</font>
$$
V = (-1)^s * M * 2^E
$$
的形式来表示一个数



<font style="font-weight:700;">~符号(sigin)</font> s决定这数是负数(s = 1)还是正数(s = 0)，而对于数值0的符号位解释作为特殊情况处理。

<font style="font-weight:700;">~尾数(significand)</font> M是一个二进制小数，它的取值范围是1~2-ε,或者0~1-ε。

<font style="font-weight:700;">~阶码(exponent)</font> E的作用是对浮点数加权，这个权重是2的E次幂(可能是负数)。



将浮点数的位表示划分三个字段，分别对这些值进行编码：
$$
\begin{aligned}
&\bullet 一个单独的符号位s直接编码符号s。 \\
&\bullet k位的阶码字段exp = e_{k-1}\cdot\cdot\cdot e_1,e_0编码阶码E。 \\
&\bullet n位小数字段frac=f_{n-1}\cdot\cdot\cdot f_1,f_0编码尾数M。但是编码出来的值也依赖于阶码字段的值是否等于0.
\end{aligned}
$$


在C语言中单精度浮点格式(float)，s、exp和frac字段分别为1位、k=8位和n=23位，得到一个32位的表示。在双精度浮点格式(double)中，s、exp和frac字段分别为1位、k=11位和n=52位，得到一个64位的表示。





根据exp的值，被编码的值可以分为三种不同的情况：

<font style="font-weight:700;">情况1：规格化的值</font> 

​	这是最普遍的情况。当exp的位模式既不全为0(数值0)，也不全为1(单精度数值为255，双精度数值为2047)时，都属于这类情况。在这种情况中，阶码字段被解释为以偏置(biased)形式表示的有符号整数。也就是说，阶码的值是E=e-Bias，其中e是无符号数，其位表示为
$$
\begin{aligned}
&e_{k-1}...e_1,e_0
\end{aligned}
$$
而Bias是一个等于
$$
\begin{aligned}
&2^{k-1}-1(单精度是127，双精度1023)
\end{aligned}
$$
的偏置值。由此产生指数的取值范围，对于单精度是-126~+127，而对于双精度是-1022~+1023.

小数字段frac被解释为描述小数值f，其中
$$
0 \leq f < 1,其二进制表示为0.f_{n-1}...f_1,f_0
$$
也就是二进制小数点在最高位的左边。尾数定义为M=1+f。有时这种方式也叫做隐含的以1开头的表示，会把这个开头隐藏掉。

<font style="font-weight:700;">情况2：非规格化的值</font>

​	当阶码域全为0时，所表示的数是非规格化形式。在这种情况下，阶码值是E=1-Bias，而尾数的值是M=f，也就是小数字段的值，不包含隐含的开头的1.

<font style="font-weight:700;">情况3：特殊值</font>

​	当阶码全为1的时候，所表示的数是特殊值。当小数域全为0时，得到的值表示无穷，当s=0时是+∞，或者s=1时是-∞。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果，当小数域为非零时，结果值被称为“NaN”，即“不是一个数(Not a Number)”的缩写.

